[{"question": "项目编译失败的原因是什么？失败日志如下: \nWorking directory: /sourcecode\nPreparing environment...\nFound gcc: /usr/bin/gcc\nFound g++: /usr/bin/g++\nFound clang: /usr/bin/clang\nFound clang++: /usr/bin/clang++\nEntering directory: /sourcecode\nExecuting command:\n/sourcecode/upb1725954060875gsof: line 2: $: command not found\nTarget project compile failed", "A": "缺少必要的编译器",
  "B": "执行了一个不存在的命令",
  "C": "源代码目录不可访问",
  "D": "编译环境未正确设置",
  "answer": "B"
},
{
  "question": "项目编译失败，失败日志如下: \nWorking directory: /sourcecode\nPreparing environment...\nFound gcc: /usr/bin/gcc\nFound g++: /usr/bin/g++\nFound clang: /usr/bin/clang\nFound clang++: /usr/bin/clang++\nEntering directory: /sourcecode\nExecuting command:\n/sourcecode/upb1725954060875gsof: line 2: $: command not found\nTarget project compile failed\n解决编译失败的方案是什么？",
  "A": "检查并修复脚本中的语法错误，确保没有错误的命令或符号",
  "B": "确认编译环境中的路径和环境变量设置正确，确保所有必要的编译工具可执行",
  "C": "安装或重新安装缺失的编译器或工具链",
  "D": "清理编译环境并重新尝试编译过程",
  "answer": "A"
},
{
  "question": "C/C++中的头文件有什么作用？",
  "A": "包含函数、变量、类的声明，以便在其他源文件中使用",
  "B": "存储实现细节，避免在多个项目或文件中重复编写相同的代码",
  "C": "提高编译速度，通过减少需要重新编译的代码量",
  "D": "用于组织代码，通过分离声明和实现",
  "answer": "A"
},
{
  "question": "如何识别C/C++中的头文件？",
  "A": "头文件是具有.h扩展名的文件，包含函数、变量、类的声明",
  "B": "头文件是具有.cpp扩展名的文件，包含函数、变量、类的定义",
  "C": "头文件是具有.c扩展名的文件，包含程序的实现代码",
  "D": "头文件是具有.txt扩展名的文件，包含文档和注释",
  "answer": "A"
},
{
  "question": "在Linux中，库文件的主要作用是什么？",
  "A": "作为可执行文件运行程序",
  "B": "提供可重用的函数、数据结构、类等",
  "C": "库文件在程序编译时或运行时发挥作用",
  "D": "用于程序的调试和错误检测",
  "answer": ["B", "C"]
},
{
  "question": "在C语言中，存在哪些类型的库？",
  "A": "动态库和静态库",
  "B": "源码库和二进制库",
  "C": "头文件库和对象文件库",
  "D": "可执行库和可链接库",
  "answer": "A"
},

{
  "question": "库文件的对象文件通常以什么扩展名结尾？",
  "A": ".o",
  "B": ".c",
  "C": ".h",
  "D": ".so",
  "answer": ["A", "D"]
},
{
  "question": "动态库和静态库在文件命名上有什么区别？",
  "A": "动态库使用'*.so'命名，静态库使用'*.a'命名",
  "B": "动态库使用'*.a'命名，静态库使用'*.so'命名",
  "C": "动态库和静态库都使用'*.so'命名",
  "D": "动态库和静态库都使用'*.a'命名",
  "answer": "A"
},
{
  "question": "动态库在程序运行时扮演什么角色？",
  "A": "动态库在编译时被锁定到程序中",
  "B": "动态库在运行时作为单独的文件存在",
  "C": "动态库不能在运行时被访问",
  "D": "动态库会增加程序的文件大小",
  "answer": "B"
},
{
  "question": "动态库和静态库在编译时的行为有何不同？",
  "A": "动态库在编译时被锁定到程序中",
  "B": "静态库在编译时被锁定到程序中",
  "C": "动态库和静态库都不会在编译时被锁定到程序中",
  "D": "动态库和静态库都会在编译时被锁定到程序中",
  "answer": "B"
},
{
  "question": "什么是模糊测试（Fuzzing）？",
  "A": "一种针对源代码的静态测试技术",
  "B": "一种自动化的黑盒测试技术，通过注入畸形或半畸形数据来发现软件中的实现错误",
  "C": "一种手动测试技术，依赖于测试者的经验",
  "answer": "B"
},
{
  "question": "模糊测试的历史可以追溯到什么时候？",
  "A": "1989年",
  "B": "1999年",
  "C": "2009年",
  "answer": "A"
},
{
  "question": "以下哪些是模糊测试的优缺点？",
  "A": "",
  "B": "",
  "C": "",
  "D": "",
  "answer": ""
},
{
  "question": "以下哪些是模糊测试的应用场景？",
  "A": "桌面应用程序的用户界面",
  "B": "网络应用程序的URL和表单",
  "C": "文件格式",
  "D": "所有选项",
  "answer": "D"
},
{
  "question": "行为模糊测试主要关注什么？",
  "A": "应用程序预期行为和实际行为之间的差异",
  "B": "源代码在运行时的分析",
  "C": "用户界面特性的测试",
  "D": "服务器对协议引入的不良内容的反应",
  "answer": "A"
},

{
  "question": "覆盖率引导的模糊测试主要分析什么？",
  "A": "应用程序预期行为和实际行为之间的差异",
  "B": "源代码在运行时的分析",
  "C": "用户界面特性的测试",
  "D": "服务器对协议引入的不良内容的反应",
  "answer": "B"
},

{
  "question": "文件格式模糊测试通常处理哪些类型的文件？",
  "A": "JPEG, XML, 或 .docx 文件",
  "B": "源代码文件",
  "C": "服务器日志文件",
  "D": "二进制可执行文件",
  "answer": "A"
},
{
  "question": "模糊测试（Fuzzing）通常用于发现哪些类型的问题？",
  "A": "内存泄漏",
  "B": "缓冲区溢出",
  "C": "输入验证错误",
  "D": "性能退化",
  "answer": ["A", "B", "C"]
},
{
  "question": "以下哪些描述适用于模糊测试？",
  "A": "模糊测试可以是黑盒或白盒测试",
  "B": "模糊测试不需要访问程序源代码",
  "C": "模糊测试可以导致程序崩溃或内存泄漏",
  "D": "模糊测试主要在生产阶段进行",
  "answer": ["A", "C"]
},
{
  "question": "模糊测试与压力测试的主要区别是什么？",
  "A": "模糊测试使用意外或无效数据",
  "B": "压力测试评估系统在极端事件或峰值负载下的处理能力",
  "C": "模糊测试关注系统性能的临界点",
  "D": "压力测试关注程序如何处理无效数据",
  "answer": ["A", "B"]
},
{
  "question": "以下哪些描述适用于模糊测试？",
  "A": "一种自动化的黑盒测试技术",
  "B": "通过注入畸形或半畸形数据来发现软件中的实现错误",
  "C": "依赖于测试者的经验",
  "D": "关注系统在极端负载下的性能",
  "answer": ["A", "B"]
},
{
  "question": "模糊测试（Fuzzing）的目的是什么？",
  "A": "发现程序的潜在安全漏洞",
  "B": "验证代码单元是否按预期工作",
  "C": "提高代码质量并简化维护",
  "D": "检查程序对意外或随机数据的反应",
  "answer": "D"
},
{
  "question": "以下哪些描述适用于单元测试？",
  "A": "测试单个代码单元以验证其功能",
  "B": "使用随机数据来测试程序",
  "C": "关注单个用例并验证输出是否符合预期",
  "D": "可能需要编写大量测试来覆盖所有输入场景",
  "answer": ["A", "C", "D"]
},
{
  "question": "模糊测试和单元测试分别属于哪种类型的测试？",
  "A": "模糊测试是正向测试，单元测试是负向测试",
  "B": "模糊测试是负向测试，单元测试是正向测试",
  "C": "模糊测试和单元测试都是正向测试",
  "D": "模糊测试和单元测试都是负向测试",
  "answer": "B"
},
{
  "question": "通常由谁来执行模糊测试和单元测试？",
  "A": "开发人员执行模糊测试，安全团队执行单元测试",
  "B": "安全团队执行模糊测试，开发人员执行单元测试",
  "C": "开发人员和安全团队都执行模糊测试",
  "D": "开发人员和安全团队都执行单元测试",
  "answer": "B"
},
{
  "question": "为什么单元测试和模糊测试应该结合使用？",
  "A": "单元测试可以发现功能错误，而模糊测试可以检测安全问题",
  "B": "模糊测试可以替代单元测试，因为它们都是自动化的",
  "C": "单元测试可以替代模糊测试，因为它们都是手动的",
  "D": "模糊测试可以发现所有类型的错误，包括功能和安全问题",
  "answer": "A"
},
{
  "question": "结合使用单元测试和模糊测试有哪些好处？",
  "A": "帮助开发者更早地发现和修复问题",
  "B": "减少了功能和安全团队之间的摩擦",
  "C": "因为它们都是针对源代码的静态测试技术",
  "D": "因为它们都是手动测试技术，依赖于测试者的经验",
  "answer": ["A", "B"]
},
{
  "question": "静态应用程序安全测试（SAST）和模糊测试的主要区别是什么？",
  "A": "SAST分析代码以发现编码缺陷，而模糊测试通过注入无效数据来发现安全弱点",
  "B": "SAST和模糊测试都是自动化的黑盒测试技术",
  "C": "SAST和模糊测试都是手动测试技术，依赖于测试者的经验",
  "D": "模糊测试可以在开发早期阶段使用，而SAST主要用于测试应用程序的运行时行为",
  "answer": "A"
},
{
  "question": "模糊测试相对于SAST的优势有哪些？",
  "A": "可以实现高达100%的代码覆盖率且没有误报",
  "B": "可以提供用于重现错误的输入，并能精确定位问题代码行",
  "C": "SAST是早期开发阶段特别有用的，而模糊测试主要用于代码审查",
  "D": "SAST可以提供运行时上下文以找到边缘情况",
  "answer": ["A", "B"]
},
{
  "question": "SAST和模糊测试如何互补？",
  "A": "SAST可以帮助识别模糊测试的目标",
  "B": "模糊测试可以在运行时提供上下文以发现边缘情况",
  "C": "SAST和模糊测试都是针对源代码的静态测试技术",
  "D": "SAST和模糊测试都是自动化的黑盒测试技术",
  "answer": ["A", "B"]
},
{
  "question": "模糊测试（Fuzzing）和动态应用程序安全测试（DAST）的主要区别是什么？",
  "A": "模糊测试需要访问程序源代码，而DAST不需要",
  "B": "模糊测试通过自动生成无效数据来发现安全风险，而DAST通过规则扫描运行中的应用程序来发现漏洞",
  "C": "DAST是黑盒测试，模糊测试是白盒测试",
  "D": "DAST在生产阶段特别有效，而模糊测试在开发早期阶段更有效",
  "answer": "B"
},
{
  "question": "动态应用程序安全测试（DAST）的主要方法是什么？",
  "A": "分析源代码以发现编码缺陷",
  "B": "从前端分析Web应用程序，通过模拟攻击来发现漏洞",
  "C": "通过注入无效或意外数据来发现安全风险",
  "D": "需要访问程序源代码",
  "answer": "B"
},
{
  "question": "模糊测试与DAST的主要区别是什么？",
  "A": "模糊测试的目标是发现特定漏洞，而DAST不是",
  "B": "模糊测试通过注入无效数据来发现安全风险",
  "C": "DAST是一种黑盒测试方法，而模糊测试不是",
  "D": "模糊测试旨在识别触发目标系统异常和崩溃的条件",
  "answer": "D"
},
{
  "question": "模糊测试（Fuzzing）和交互式应用程序安全测试（IAST）的主要区别是什么？",
  "A": "模糊测试需要实时监控应用程序的行为和代码，而IAST不需要",
  "B": "模糊测试通过自动生成并注入无效数据给程序，监控程序行为来发现安全风险，而IAST使用软件插桩来收集并分析程序运行时信息已识别安全风险",
  "C": "模糊测试是手动的，而IAST是自动化的",
  "D": "IAST可以检测在执行期间显现的问题，而模糊测试不能",
  "answer": "B"
},
{
  "question": "什么是模糊测试驱动（Fuzz Harness）？",
  "A": "一个用于在模糊测试中生成有效负载的工具",
  "B": "一个用于将模糊测试输入转换为应用程序可理解格式的工具",
  "C": "一个用于自动化测试应用程序性能的工具",
  "D": "一个用于手动测试应用程序安全性的工具",
  "answer": "B"
},
{
  "question": "模糊测试驱动的主要作用是什么？",
  "A": "生成畸形或半畸形数据",
  "B": "将模糊测试输入转换为应用程序可理解的格式",
  "C": "提供手动测试的指导",
  "D": "模拟用户与应用程序的正常交互",
  "answer": "B"
},
{
  "question": "为什么需要模糊测试驱动？",
  "A": "因为模糊测试工具（Fuzzer）无法生成所有类型的有效负载",
  "B": "因为应用程序可能需要特定方式的输入",
  "C": "因为手动测试需要自动化工具的支持",
  "D": "因为模糊测试工具无法理解应用程序的逻辑",
  "answer": "B"
},
{
  "question": "以下哪个例子说明了测试驱动的用途？",
  "A": "从文件读取输入并将其传递给要模糊测试的易受攻击的函数",
  "B": "编写一个程序来模拟用户输入",
  "C": "创建一个自动化测试脚本",
  "D": "生成畸形或半畸形数据",
  "answer": "A"
},
{
  "question": "编写模糊测试驱动通常需要哪些条件？",
  "A": "对项目有充分的背景知识",
  "B": "能够使用自动化工具生成测试用例",
  "C": "对模糊测试工具（Fuzzer）有充分的了解",
  "D": "需要几个小时的手动工作",
  "answer": ["A", "C"]
},
{
  "question": "CWE-122是什么类型的安全漏洞？",
  "A": "一种基于堆的缓冲区溢出漏洞",
  "B": "Heap-based Buffer Overflow",
  "C": "一种交互式应用程序安全测试（IAST）",
  "D": "一种模糊测试（Fuzzing）",
  "answer": ["A", "B"]
},
{
  "question": "堆溢出（Heap-based Buffer Overflow）通常会导致哪些后果？",
  "A": "程序崩溃",
  "B": "执行任意代码",
  "C": "应用程序进入无限循环",
  "D": "提高应用程序性能",
  "answer": ["A", "B", "C"]
},
{
  "question": "哪些措施可以用来缓解CWE-122: Heap-based Buffer Overflow？",
  "A": "使用执行自动边界检查的语言或编译器",
  "B": "手动检查所有缓冲区操作",
  "C": "增加内存分配的大小以避免溢出",
  "D": "禁用所有外部输入",
  "answer": "A"
},
{
  "question": "以下代码片段是否存在CWE-122: Heap-based Buffer Overflow缺陷？int main(int argc, char **argv) { char *buf; buf = (char *)malloc(sizeof(char)*BUFSIZE); strcpy(buf, argv[1]); }",
  "A": "是的，因为`strcpy`在没有检查大小的情况下复制输入到堆分配的缓冲区",
  "B": "不是，因为`BUFSIZE`定义的缓冲区大小足以容纳任何输入",
  "C": "无法确定，因为没有提供`BUFSIZE`的具体大小",
  "D": "不是，因为使用了`malloc`进行内存分配，这可以防止溢出",
  "answer": "A"
},
{
  "question": "以下代码片段是否存在CWE-122: Heap-based Buffer Overflow缺陷？char * copy_input(char *user_supplied_string){ int i, dst_index; char *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE); if ( MAX_SIZE <= strlen(user_supplied_string) ){ die(\"user string too long, die evil hacker!\"); } dst_index = 0; for ( i = 0; i < strlen(user_supplied_string); i++ ){ if( '&' == user_supplied_string[i] ){ dst_buf[dst_index++] = '&'; dst_buf[dst_index++] = 'a'; dst_buf[dst_index++] = 'm'; dst_buf[dst_index++] = 'p'; dst_buf[dst_index++] = ';'; } else if ('<' == user_supplied_string[i] ){ /* encode to &lt; */ } else dst_buf[dst_index++] = user_supplied_string[i]; } return dst_buf;",
  "A": "是的，因为代码中没有检查`dst_buf`的大小",
  "B": "不是，因为代码中有检查输入字符串长度是否超过`MAX_SIZE`",
  "C": "无法确定，因为代码片段不完整",
  "D": "不是，因为即使输入长度超过`MAX_SIZE`，程序会调用`die`函数",
  "answer": "A"
}]